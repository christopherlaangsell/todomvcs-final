["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ ","~$console","~$re-frame.loggers","~$reaction","~$reagent.ratom"],"~:excludes",["~#set",[]],"~:name","~$re-posh.subs","~:imports",null,"~:requires",["^ ","~$r","~$re-frame.core","^=","^=","^4","^4","~$re-posh.db","^>","^6","^6","~$p","~$posh.reagent","^?","^?"],"~:cljs.spec/speced-vars",[],"~:uses",["^ ","^3","^4","~$store","^>"],"~:defs",["^ ","~$execute-sub",["^ ","^9","~$re-posh.subs/execute-sub","~:file","resources/public/cljs-out/dev/re_posh/subs.cljc","~:line",9,"~:column",1,"~:end-line",9,"~:end-column",22,"~:meta",["^ ","^F","/Users/christophergsell/Documents/2021-2022/COMP992/implementations/re-posh/re-posh/examples/todomvc/resources/public/cljs-out/dev/re_posh/subs.cljc","^G",9,"^H",11,"^I",9,"^J",22],"~:tag","~$cljs.core/MultiFn"],"~$reg-sub",["^ ","~:protocol-inline",null,"^K",["^ ","^F","/Users/christophergsell/Documents/2021-2022/COMP992/implementations/re-posh/re-posh/examples/todomvc/resources/public/cljs-out/dev/re_posh/subs.cljc","^G",24,"^H",7,"^I",24,"^J",14,"~:arglists",["~#list",["~$quote",["^Q",[["~$query-id","~$&","~$args"]]]]],"~:doc","For a given `query-id` register a `config` function and input `signals`\n\n  At an abstract level, a call to this function allows you to register 'the mechanism'\n  to later fulfil a call to `(subscribe [query-id ...])`.\n\n  To say that another way, reg-sub allows you to create a template for a node\n  in the signal graph. But note: reg-sub does not cause a node to be created.\n  It simply allows you to register the template from which such a\n  node could be created, if it were needed, sometime later, when the call\n  to `subscribe` is made.\n\n  reg-sub needs three things:\n    - a `query-id`\n    - the required inputs for this node\n    - a function that generates config for query or pull for this node\n\n  The `query-id` is always the 1st argument to reg-sub and it is typically\n  a namespaced keyword.\n\n  A config function is always the last argument and it has this general form:\n  `(input-signals, query-vector) -> a-value`\n\n  What goes in between the 1st and last args can vary, but whatever is there will\n  define the input signals part of the template, and, as a result, it will control\n  what values the config functions gets as a first argument.\n  There's 3 ways this function can be called - 3 ways to supply input signals:\n\n  1. No input signals given:\n\n     (reg-sub\n       :query-id\n       a-config-fn)   ;; (fn [db v]  ... a-value)\n     The node's input signal defaults to datascript database, and the value within `ds` is\n     is given as the 1st argument to the computation function.\n\n  2. A signal function is supplied:\n\n     (reg-sub\n       :query-id\n       signal-fn     ;; <-- here, the form is (fn [db v] ... signal | [signal])\n       config-fn)\n\n     When a node is created from the template, the `signal-fn` will be called and it\n     is expected to return the input signal(s) as either a singleton, if there is only\n     one, or a sequence if there are many.\n     The values from the nominated signals will be supplied as the 1st argument to the\n     config function - either a singleton or sequence, paralleling\n     the structure returned by the signal function.\n     Here, is an example signal-fn, which returns a vector of input signals.\n       (fn [query-vec]\n         [(subscribe [:a-sub])\n          (subscribe [:b-sub])])\n     For that signal function, the config function must be written\n     to expect a vector of values for its first argument.\n       (fn [[a b] _] ....)\n     If the signal function was simpler and returned a singleton, like this:\n        (fn [query-vec dynamic-vec]\n          (subscribe [:a-sub]))\n     then the config function must be written to expect a single value\n     as the 1st argument:\n        (fn [a _] ...)\n\n  3. Syntax Sugar\n\n     (reg-sub\n       :a-b-sub\n       :<- [:a-sub]\n       :<- [:b-sub]\n       (fn [[a b] [_]] {:a a :b b}))\n\n  This 3rd variation is syntactic sugar for the 2nd. Pairs are supplied instead\n  of an `input signals` functions. Each pair starts with a `:<-` and a subscription\n  vector follows.\n  ","~:top-fn",["^ ","~:variadic?",true,"~:fixed-arity",1,"~:max-fixed-arity",1,"~:method-params",[["^Q",["^S","^T"]]],"^P",["^Q",[["^S","~$&","^T"]]],"~:arglists-meta",["^Q",[null]]]],"^9","~$re-posh.subs/reg-sub","^F","resources/public/cljs-out/dev/re_posh/subs.cljc","^J",14,"^V",["^ ","^W",true,"^X",1,"^Y",1,"^Z",[["^Q",["^S","^T"]]],"^P",["^Q",[["^S","~$&","^T"]]],"^[",["^Q",[null]]],"^Z",[["^Q",["^S","^T"]]],"~:protocol-impl",null,"^X",1,"^[",["^Q",[null]],"^H",1,"^W",true,"~:methods",[["^ ","^X",1,"^W",true,"^L","~$any"]],"^G",24,"~:ret-tag","^13","^I",24,"^Y",1,"~:fn-var",true,"^P",["^Q",[["^S","~$&","^T"]]],"^U","For a given `query-id` register a `config` function and input `signals`\n\n  At an abstract level, a call to this function allows you to register 'the mechanism'\n  to later fulfil a call to `(subscribe [query-id ...])`.\n\n  To say that another way, reg-sub allows you to create a template for a node\n  in the signal graph. But note: reg-sub does not cause a node to be created.\n  It simply allows you to register the template from which such a\n  node could be created, if it were needed, sometime later, when the call\n  to `subscribe` is made.\n\n  reg-sub needs three things:\n    - a `query-id`\n    - the required inputs for this node\n    - a function that generates config for query or pull for this node\n\n  The `query-id` is always the 1st argument to reg-sub and it is typically\n  a namespaced keyword.\n\n  A config function is always the last argument and it has this general form:\n  `(input-signals, query-vector) -> a-value`\n\n  What goes in between the 1st and last args can vary, but whatever is there will\n  define the input signals part of the template, and, as a result, it will control\n  what values the config functions gets as a first argument.\n  There's 3 ways this function can be called - 3 ways to supply input signals:\n\n  1. No input signals given:\n\n     (reg-sub\n       :query-id\n       a-config-fn)   ;; (fn [db v]  ... a-value)\n     The node's input signal defaults to datascript database, and the value within `ds` is\n     is given as the 1st argument to the computation function.\n\n  2. A signal function is supplied:\n\n     (reg-sub\n       :query-id\n       signal-fn     ;; <-- here, the form is (fn [db v] ... signal | [signal])\n       config-fn)\n\n     When a node is created from the template, the `signal-fn` will be called and it\n     is expected to return the input signal(s) as either a singleton, if there is only\n     one, or a sequence if there are many.\n     The values from the nominated signals will be supplied as the 1st argument to the\n     config function - either a singleton or sequence, paralleling\n     the structure returned by the signal function.\n     Here, is an example signal-fn, which returns a vector of input signals.\n       (fn [query-vec]\n         [(subscribe [:a-sub])\n          (subscribe [:b-sub])])\n     For that signal function, the config function must be written\n     to expect a vector of values for its first argument.\n       (fn [[a b] _] ....)\n     If the signal function was simpler and returned a singleton, like this:\n        (fn [query-vec dynamic-vec]\n          (subscribe [:a-sub]))\n     then the config function must be written to expect a single value\n     as the 1st argument:\n        (fn [a _] ...)\n\n  3. Syntax Sugar\n\n     (reg-sub\n       :a-b-sub\n       :<- [:a-sub]\n       :<- [:b-sub]\n       (fn [[a b] [_]] {:a a :b b}))\n\n  This 3rd variation is syntactic sugar for the 2nd. Pairs are supplied instead\n  of an `input signals` functions. Each pair starts with a `:<-` and a subscription\n  vector follows.\n  "],"~$reg-query-sub",["^ ","^O",null,"^K",["^ ","^F","/Users/christophergsell/Documents/2021-2022/COMP992/implementations/re-posh/re-posh/examples/todomvc/resources/public/cljs-out/dev/re_posh/subs.cljc","^G",146,"^H",7,"^I",146,"^J",20,"^P",["^Q",["^R",["^Q",[["~$sub-name","~$query"]]]]],"^U","Syntax sugar for writing queries. It allows writing query subscription\n   in a very simple way:\n\n  (re-posh/reg-query-sub\n   :query-id\n   '[:find ...\n     :in $ $1 $2  ;; <- all variables go here\n     :where ...])\n\n  It's possible to subscibe to this query with\n\n  (re-posh/subscribe [:query-id var-1 var-2])\n\n  so that variables `var-1` and `var-2` will be automatically sent to `:in` form\n  "],"^9","~$re-posh.subs/reg-query-sub","^F","resources/public/cljs-out/dev/re_posh/subs.cljc","^J",20,"^Z",["^Q",[["^17","^18"]]],"^11",null,"^[",["^Q",[null,null]],"^H",1,"^W",false,"^G",146,"^14","^13","^I",146,"^Y",2,"^15",true,"^P",["^Q",["^R",["^Q",[["^17","^18"]]]]],"^U","Syntax sugar for writing queries. It allows writing query subscription\n   in a very simple way:\n\n  (re-posh/reg-query-sub\n   :query-id\n   '[:find ...\n     :in $ $1 $2  ;; <- all variables go here\n     :where ...])\n\n  It's possible to subscibe to this query with\n\n  (re-posh/subscribe [:query-id var-1 var-2])\n\n  so that variables `var-1` and `var-2` will be automatically sent to `:in` form\n  "],"~$reg-pull-sub",["^ ","^O",null,"^K",["^ ","^F","/Users/christophergsell/Documents/2021-2022/COMP992/implementations/re-posh/re-posh/examples/todomvc/resources/public/cljs-out/dev/re_posh/subs.cljc","^G",170,"^H",7,"^I",170,"^J",19,"^P",["^Q",["^R",["^Q",[["^17","~$pattern"]]]]],"^U","Syntax sugar for writing pull queries. It allows writing pull subscription\n  in a very simple way:\n\n  (re-posh/reg-pull-sub\n   :pull-id\n   '[*]) ;;<- pull pattern\n\n  It's possible to subscribe to this pull query with\n\n  (re-posh/subscibe [:pull-id id])\n\n  Where id is an entity id"],"^9","~$re-posh.subs/reg-pull-sub","^F","resources/public/cljs-out/dev/re_posh/subs.cljc","^J",19,"^Z",["^Q",[["^17","^1;"]]],"^11",null,"^[",["^Q",[null,null]],"^H",1,"^W",false,"^G",170,"^14","^13","^I",170,"^Y",2,"^15",true,"^P",["^Q",["^R",["^Q",[["^17","^1;"]]]]],"^U","Syntax sugar for writing pull queries. It allows writing pull subscription\n  in a very simple way:\n\n  (re-posh/reg-pull-sub\n   :pull-id\n   '[*]) ;;<- pull pattern\n\n  It's possible to subscribe to this pull query with\n\n  (re-posh/subscibe [:pull-id id])\n\n  Where id is an entity id"],"~$reg-pull-many-sub",["^ ","^O",null,"^K",["^ ","^F","/Users/christophergsell/Documents/2021-2022/COMP992/implementations/re-posh/re-posh/examples/todomvc/resources/public/cljs-out/dev/re_posh/subs.cljc","^G",191,"^H",7,"^I",191,"^J",24,"^P",["^Q",["^R",["^Q",[["^17","^1;"]]]]],"^U","Syntax sugar for writing pull-many queries.\n  Same as reg-pull-sub but takes vector of eids under key :ids\n\n  (reg-pull-many-sub\n   :things\n   '[*])\n\n  It's possible to subscribe to this pull-many query with\n\n  (re-posh/subscribe [:things ids])\n\n  Where ids is a sequence of entity ids"],"^9","~$re-posh.subs/reg-pull-many-sub","^F","resources/public/cljs-out/dev/re_posh/subs.cljc","^J",24,"^Z",["^Q",[["^17","^1;"]]],"^11",null,"^[",["^Q",[null,null]],"^H",1,"^W",false,"^G",191,"^14","^13","^I",191,"^Y",2,"^15",true,"^P",["^Q",["^R",["^Q",[["^17","^1;"]]]]],"^U","Syntax sugar for writing pull-many queries.\n  Same as reg-pull-sub but takes vector of eids under key :ids\n\n  (reg-pull-many-sub\n   :things\n   '[*])\n\n  It's possible to subscribe to this pull-many query with\n\n  (re-posh/subscribe [:things ids])\n\n  Where ids is a sequence of entity ids"]],"~:cljs.spec/registry-ref",[],"~:require-macros",["^ ","^6","^6"],"~:cljs.analyzer/constants",["^ ","~:seen",["^8",["~:pull-many","~:<-","~:default","~:ids","~:type","~:variables","~:id","~:error","~:query","~:pull","~:hierarchy","~:pattern"]],"~:order",["^1M","^1G","^1E","^1K","^1H","^1L","^1N","^1I","^1C","^1F","^1J","^1D"]],"^U",null]